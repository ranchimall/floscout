<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1.0" />
	<title>FLO Scout</title>
	<link rel="stylesheet" href="css/main.min.css" />
	<link rel="preconnect" href="https://fonts.googleapis.com">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
	<script src="https://unpkg.com/uhtml@3.0.1/es.js"></script>
	<script src="scripts/components.min.js"></script>
	<script src="scripts/lib.js" defer></script>
	<script src="scripts/floCrypto.js" defer></script>
	<link rel="shortcut icon" href="floscout.svg" type="image/x-icon">
</head>

<body class="hidden">
	<sm-notifications id="notification_drawer"></sm-notifications>
	<div id="loading">
		<sm-spinner></sm-spinner>
		<h4>Loading</h4>
	</div>
	<header id="main_header" class="margin">
		<a href="#/home" id="logo" class=" flex align-center gap-0-3">
			<svg id="main_logo" class="icon" viewBox="0 0 27.25 32">
				<title>RanchiMall</title>
				<path
					d="M27.14,30.86c-.74-2.48-3-4.36-8.25-6.94a20,20,0,0,1-4.2-2.49,6,6,0,0,1-1.25-1.67,4,4,0,0,1,0-2.26c.37-1.08.79-1.57,3.89-4.55a11.66,11.66,0,0,0,3.34-4.67,6.54,6.54,0,0,0,.05-2.82C20,3.6,18.58,2,16.16.49c-.89-.56-1.29-.64-1.3-.24a3,3,0,0,1-.3.72l-.3.55L13.42.94C13,.62,12.4.26,12.19.15c-.4-.2-.73-.18-.72.05a9.39,9.39,0,0,1-.61,1.33s-.14,0-.27-.13C8.76.09,8-.27,8,.23A11.73,11.73,0,0,1,6.76,2.6C4.81,5.87,2.83,7.49.77,7.49c-.89,0-.88,0-.61,1,.22.85.33.92,1.09.69A5.29,5.29,0,0,0,3,8.33c.23-.17.45-.29.49-.26a2,2,0,0,1,.22.63A1.31,1.31,0,0,0,4,9.34a5.62,5.62,0,0,0,2.27-.87L7,8l.13.55c.19.74.32.82,1,.65a7.06,7.06,0,0,0,3.46-2.47l.6-.71-.06.64c-.17,1.63-1.3,3.42-3.39,5.42L6.73,14c-3.21,3.06-3,5.59.6,8a46.77,46.77,0,0,0,4.6,2.41c.28.13,1,.52,1.59.87,3.31,2,4.95,3.92,4.95,5.93a2.49,2.49,0,0,0,.07.77h0c.09.09,0,.1.9-.14a2.61,2.61,0,0,0,.83-.32,3.69,3.69,0,0,0-.55-1.83A11.14,11.14,0,0,0,17,26.81a35.7,35.7,0,0,0-5.1-2.91C9.37,22.64,8.38,22,7.52,21.17a3.53,3.53,0,0,1-1.18-2.48c0-1.38.71-2.58,2.5-4.23,2.84-2.6,3.92-3.91,4.67-5.65a3.64,3.64,0,0,0,.42-2A3.37,3.37,0,0,0,13.61,5l-.32-.74.29-.48c.17-.27.37-.63.46-.8l.15-.3.44.64a5.92,5.92,0,0,1,1,2.81,5.86,5.86,0,0,1-.42,1.94c0,.12-.12.3-.15.4a9.49,9.49,0,0,1-.67,1.1,28,28,0,0,1-4,4.29C8.62,15.49,8.05,16.44,8,17.78a3.28,3.28,0,0,0,1.11,2.76c.95,1,2.07,1.74,5.25,3.32,3.64,1.82,5.22,2.9,6.41,4.38A4.78,4.78,0,0,1,21.94,31a3.21,3.21,0,0,0,.14.92,1.06,1.06,0,0,0,.43-.05l.83-.22.46-.12-.06-.46c-.21-1.53-1.62-3.25-3.94-4.8a37.57,37.57,0,0,0-5.22-2.82A13.36,13.36,0,0,1,11,21.19a3.36,3.36,0,0,1-.8-4.19c.41-.85.83-1.31,3.77-4.15,2.39-2.31,3.43-4.13,3.43-6a5.85,5.85,0,0,0-2.08-4.29c-.23-.21-.44-.43-.65-.65A2.5,2.5,0,0,1,15.27.69a10.6,10.6,0,0,1,2.91,2.78A4.16,4.16,0,0,1,19,6.16a4.91,4.91,0,0,1-.87,3c-.71,1.22-1.26,1.82-4.27,4.67a9.47,9.47,0,0,0-2.07,2.6,2.76,2.76,0,0,0-.33,1.54,2.76,2.76,0,0,0,.29,1.47c.57,1.21,2.23,2.55,4.65,3.73a32.41,32.41,0,0,1,5.82,3.24c2.16,1.6,3.2,3.16,3.2,4.8a1.94,1.94,0,0,0,.09.76,4.54,4.54,0,0,0,1.66-.4C27.29,31.42,27.29,31.37,27.14,30.86ZM6.1,7h0a3.77,3.77,0,0,1-1.46.45L4,7.51l.68-.83a25.09,25.09,0,0,0,3-4.82A12,12,0,0,1,8.28.76c.11-.12.77.32,1.53,1l.63.58-.57.84A10.34,10.34,0,0,1,6.1,7Zm5.71-1.78A9.77,9.77,0,0,1,9.24,7.18h0a5.25,5.25,0,0,1-1.17.28l-.58,0,.65-.78a21.29,21.29,0,0,0,2.1-3.12c.22-.41.42-.76.44-.79s.5.43.9,1.24L12,5ZM13.41,3a2.84,2.84,0,0,1-.45.64,11,11,0,0,1-.9-.91l-.84-.9.19-.45c.34-.79.39-.8,1-.31A9.4,9.4,0,0,1,13.8,2.33q-.18.34-.39.69Z" />
			</svg>
			<h4>
				FLO Scout
			</h4>
		</a>
		<div id="search_wrapper">
			<sm-input id='main_search_field' type="search"
				placeholder="block, transactions, address, token or contract">
				<svg class="icon" slot="icon" xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 0 24 24"
					width="24px" fill="#000000">
					<path d="M0 0h24v24H0V0z" fill="none" />
					<path
						d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z" />
				</svg>
			</sm-input>
			<ul id="suggestions"></ul>
		</div>
		<theme-toggle></theme-toggle>
	</header>
	<div id="page_header" class="flex margin">
		<button class="icon-only" onclick="history.back()">
			<svg class="icon" xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 0 24 24" width="24px"
				fill="#000000">
				<path d="M0 0h24v24H0V0z" fill="none" />
				<path d="M20 11H7.83l5.59-5.59L12 4l-8 8 8 8 1.41-1.41L7.83 13H20v-2z" />
			</svg>
		</button>
		<h4 id="page_title"></h4>
	</div>
	<main id="page_container" class="flex flex-direction-column"></main>

	<!-- Set urls for token and flo Apis -->
	<script>
		let floGlobals = {
			blockchain: "FLO",
			tokenApiUrl: 'https://ranchimallflov2.ranchimall.net',
			floApiUrl: 'https://flosight.ranchimall.net',
		}
	</script>
	<script>
		/*jshint esversion: 8 */
		/**
		  * @yaireo/relative-time - javascript function to transform timestamp or date to local relative-time
		  *
		  * @version v1.0.0
		  * @homepage https://github.com/yairEO/relative-time
		  */
		!function (e, t) { var o = o || {}; "function" == typeof o && o.amd ? o([], t) : "object" == typeof exports && "object" == typeof module ? module.exports = t() : "object" == typeof exports ? exports.RelativeTime = t() : e.RelativeTime = t() }(this, (function () { const e = { year: 31536e6, month: 2628e6, day: 864e5, hour: 36e5, minute: 6e4, second: 1e3 }, t = "en", o = { numeric: "auto" }; function n(e) { e = { locale: (e = e || {}).locale || t, options: { ...o, ...e.options } }, this.rtf = new Intl.RelativeTimeFormat(e.locale, e.options) } return n.prototype = { from(t, o) { const n = t - (o || new Date); for (let t in e) if (Math.abs(n) > e[t] || "second" == t) return this.rtf.format(Math.round(n / e[t]), t) } }, n }));
		const relativeTime = new RelativeTime({ style: 'narrow' });
	</script>
	<script>
		"use strict";
		// Global variables
		const { html, render: renderElem } = uhtml;
		//Checks for internet connection status
		if (!navigator.onLine)
			floGlobals.connectionErrorNotification = notify('There seems to be a problem connecting to the internet, Please check you internet connection.', 'error')
		window.addEventListener('offline', () => {
			floGlobals.connectionErrorNotification = notify('There seems to be a problem connecting to the internet, Please check you internet connection.', 'error')
		})
		window.addEventListener('online', () => {
			getRef('notification_drawer').remove(floGlobals.connectionErrorNotification)
			notify('We are back online.', 'success')
		})
		//Function for displaying toast notifications. pass in error for mode param if you want to show an error.
		function notify(message, mode, options = {}) {
			let icon
			switch (mode) {
				case 'success':
					icon = `<svg class="icon icon--success" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24"><path fill="none" d="M0 0h24v24H0z"/><path d="M10 15.172l9.192-9.193 1.415 1.414L10 18l-6.364-6.364 1.414-1.414z"/></svg>`
					break;
				case 'error':
					icon = `<svg class="icon icon--error" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24"><path fill="none" d="M0 0h24v24H0z"/><path d="M12 22C6.477 22 2 17.523 2 12S6.477 2 12 2s10 4.477 10 10-4.477 10-10 10zm-1-7v2h2v-2h-2zm0-8v6h2V7h-2z"/></svg>`
					options.pinned = true
					break;
			}
			if (mode === 'error') {
				console.error(message)
			}
			return getRef("notification_drawer").push(message, { icon, ...options });
		}
		// Use instead of document.getElementById
		const domRefs = {};
		function getRef(elementId) {
			if (!domRefs.hasOwnProperty(elementId)) {
				domRefs[elementId] = {
					count: 1,
					ref: null,
				};
				return document.getElementById(elementId);
			} else {
				if (domRefs[elementId].count < 3) {
					domRefs[elementId].count = domRefs[elementId].count + 1;
					return document.getElementById(elementId);
				} else {
					if (!domRefs[elementId].ref)
						domRefs[elementId].ref = document.getElementById(elementId);
					return domRefs[elementId].ref;
				}
			}
		}

		// Use when a function needs to be executed after user finishes changes
		const debounce = (callback, wait) => {
			let timeoutId = null;
			return (...args) => {
				window.clearTimeout(timeoutId);
				timeoutId = window.setTimeout(() => {
					callback.apply(null, args);
				}, wait);
			};
		}

		function formatAmount(amount = 0, currency = 'inr') {
			if (!amount)
				return '0';
			return amount.toLocaleString(currency === 'inr' ? `en-IN` : 'en-US', { currency, maximumFractionDigits: 8 })
		}
		// fetch data and return json
		async function fetchJson(url, options = {}) {
			const response = await fetch(url, options)
			const json = await response.json()
			if (response.ok) {
				return json
			} else {
				console.error(json)
				throw new Error(json.description)
			}
		}
		function getFormattedTime(timestamp, format) {
			try {
				timestamp = parseInt(timestamp)
				if (String(timestamp).length < 13)
					timestamp *= 1000
				let [day, month, date, year] = new Date(timestamp).toString().split(' '),
					minutes = new Date(timestamp).getMinutes(),
					hours = new Date(timestamp).getHours(),
					currentTime = new Date().toString().split(' ')

				minutes = minutes < 10 ? `0${minutes}` : minutes
				let finalHours = ``;
				if (hours > 12)
					finalHours = `${hours - 12}:${minutes}`
				else if (hours === 0)
					finalHours = `12:${minutes}`
				else
					finalHours = `${hours}:${minutes}`

				finalHours = hours >= 12 ? `${finalHours} PM` : `${finalHours} AM`
				switch (format) {
					case 'date-only':
						return `${month} ${date}, ${year}`;
						break;
					case 'time-only':
						return finalHours;
					case 'relative':
						return relativeTime.from(timestamp)
					default:
						return `${month} ${date}, ${year} at ${finalHours}`;
				}
			} catch (e) {
				console.error(e);
				return timestamp;
			}
		}
		window.addEventListener("load", () => {
			document.body.classList.remove('hidden')
			document.addEventListener("pointerdown", (e) => {
				if (e.target.closest("button, .interact")) {
					createRipple(e, e.target.closest("button, .interact"));
				}
			});
			document.addEventListener('copy', () => {
				notify('copied', 'success')
			})
			getAllSuggestions().then(suggestions => {
				router.routeTo(window.location.hash)
			}).catch(e => {
				console.error(e)
				notify(e, 'error')
			})
			getRef("main_search_field").addEventListener("keydown", function (e) {
				if (e.key === 'Enter') {
					processNavbarSearch()
				} else if (e.key === 'ArrowDown') {
					e.preventDefault();
					getRef('suggestions').firstElementChild.focus()
				}
				if (document.activeElement.classList.contains('suggestion'))
					getRef("main_search_field").value = document.activeElement.textContent.trim()
			});
			getRef('suggestions').addEventListener("keydown", function (e) {
				if (e.key === 'ArrowDown') {
					e.preventDefault();
					if (this.contains(document.activeElement) && document.activeElement.nextElementSibling)
						document.activeElement.nextElementSibling.focus()
				} else if (e.key === 'ArrowUp') {
					e.preventDefault();
					if (this.contains(document.activeElement)) {
						if (document.activeElement.previousElementSibling)
							document.activeElement.previousElementSibling.focus()
						else
							getRef("main_search_field").focusIn()
					}
				}
				if (document.activeElement.classList.contains('suggestion'))
					getRef("main_search_field").value = document.activeElement.textContent.trim()
			});

			this.addEventListener("click", (e) => {
				if (e.target.closest('.suggestion')) {
					let searchBox = document.getElementById('main_search_field');
					searchBox.value = e.target.textContent;
					processNavbarSearch()
				}
			});
		});

		function createRipple(event, target) {
			const circle = document.createElement("span");
			const diameter = Math.max(target.clientWidth, target.clientHeight);
			const radius = diameter / 2;
			const targetDimensions = target.getBoundingClientRect();
			circle.style.width = circle.style.height = `${diameter}px`;
			circle.style.left = `${event.clientX - (targetDimensions.left + radius)}px`;
			circle.style.top = `${event.clientY - (targetDimensions.top + radius)}px`;
			circle.classList.add("ripple");
			const rippleAnimation = circle.animate(
				[
					{
						transform: "scale(3)",
						opacity: 0,
					},
				],
				{
					duration: 1000,
					fill: "forwards",
					easing: "ease-out",
				}
			);
			target.append(circle);
			rippleAnimation.onfinish = () => {
				circle.remove();
			};
		}

		class Router {
			constructor(options = {}) {
				const { routes = {}, state = {}, routingStart, routingEnd } = options
				this.routes = routes
				this.state = state
				this.routingStart = routingStart
				this.routingEnd = routingEnd
				window.addEventListener('hashchange', e => this.routeTo(window.location.hash))
			}
			addRoute(route, callback) {
				this.routes[route] = callback
			}
			async routeTo(path) {
				let page
				let wildcards = []
				let queryString
				let params
				[path, queryString] = path.split('?');
				if (path.includes('#'))
					path = path.split('#')[1];
				if (path.includes('/'))
					[, page, ...wildcards] = path.split('/')
				else
					page = path
				this.state = { page, wildcards }
				if (queryString) {
					params = new URLSearchParams(queryString)
					this.state.params = Object.fromEntries(params)
				}
				if (this.routingStart) {
					this.routingStart(this.state)
				}
				if (this.routes[page]) {
					await this.routes[page](this.state)
					this.state.lastPage = page
				} else {
					this.routes['404'](this.state)
				}
				if (this.routingEnd) {
					this.routingEnd(this.state)
				}
			}
		}
		const router = new Router({
			routingStart(state) {
				loading()
				if ("scrollRestoration" in history) {
					history.scrollRestoration = "manual";
				}
				window.scrollTo(0, 0);
				if (state.page !== 'home')
					getRef("page_header").classList.remove("hidden");
			},
			routingEnd() {
				loading(false)
			}
		})
		async function renderHome(state) {
			getRef("page_header").classList.add("hidden");
			let [data, latestTxs, latestBlocks] = await Promise.all([getBannerData(), getLatestTxs(), getAllBlocks(6)])
			renderElem(getRef("page_container"), html`${render.homepage({ ...data, latestBlock: latestBlocks[0] })}`);
			renderTransactions('top_transaction_container', latestTxs)
			const renderedBlocks = latestBlocks.map(block => render.blockCard(block))
			renderElem(document.getElementById('top_blocks_container'), html`${renderedBlocks}`)
		}
		router.addRoute('', async (state) => {
			history.replaceState({}, '', '#/home')
			await renderHome(state)
		})
		router.addRoute('home', renderHome)
		router.addRoute('address', async state => {
			try {
				const [floAddress] = state.wildcards
				if (!floAddress) return;
				let [ownedTokens, floBalance, addressTxs] = await Promise.all([getAddressInfo(floAddress), getAddressBalance(floAddress), getAddressTxs(floAddress)])
				renderElem(getRef("page_container"), html`${render.addressPage({ floBalance, floAddress, ownedTokens })}`);
				getRef("page_title").textContent = 'Address'
				renderTransactions('address_transaction_container', addressTxs)
			} catch (e) {
				console.error(e)
				renderElem(getRef("page_container"), html`${render.errorPage(e)}`);
			}
		})
		router.addRoute('token', async state => {
			const token = state.wildcards[0].toLowerCase()
			if (!token) return;
			try {
				let [tokenInfo, tokenBalances, tokenTransactions] = await Promise.all([getTokenInfo(token), getTokenBalances(token), getTokenTransactions(token)])
				const tokenHolders = []
				for (const address in tokenBalances) {
					tokenHolders.push(render.addrBalanceCard(address, tokenBalances[address], tokenInfo.token))
				}
				renderElem(getRef("page_container"), html`${render.tokenPage(tokenInfo)}`);
				getRef("page_title").textContent = "Token";
				renderElem(document.getElementById('token_balance_container'), html`${tokenHolders?.length ? tokenHolders : html`<div>No token holders found</div>`}`)
				renderTransactions('token_transaction_container', tokenTransactions)
			} catch (e) {
				console.log(e)
				renderElem(getRef("page_container"), html`${render.errorPage(e)}`);
			}
		})
		router.addRoute('contract', async state => {
			try {
				const [contractId] = state.wildcards
				if (!contractId) return;
				const contract = splitContractNameAddress(contractId);
				const contractInfo = await getContractInfo(contract)
				const { contractType, contractSubtype, acceptingToken, sellingToken } = contractInfo
				const detailsToFetch = [getContractTransactions(contract), getContractParticipants(contract)]
				if (contractType === 'continuos-event' && contractSubtype === 'tokenswap')
					detailsToFetch.push(getContractDeposits(contract))
				let [contractTransactions, contractParticipants, contractDeposits] = await Promise.all(detailsToFetch)
				renderElem(getRef("page_container"), html`${render.contractPage(contractInfo)}`);
				getRef("page_title").textContent = "Contract";

				// append latest transactions
				renderTransactions('contract_transaction_container', contractTransactions)
				console.log(contractParticipants)
				switch (contractType) {
					case 'one-time-event':
						switch (contractSubtype) {
							case 'external-trigger':
								let winners = []
								for (const participant in contractParticipants) {
									if (contractParticipants[participant].winningAmount)
										winners.push(contractParticipants[participant])
								}
								if (winners.length) {
									renderElem(document.getElementById('winners_container'), html`${winners.map(winner => render.contractChoiceCard(winner))}`)
								} else {
									renderElem(document.getElementById('winners_container'), html`<div>No winners found</div>`)
								}
								break;
							default:
								break
						}
						if (Object.keys(contractParticipants).length)
							renderElem(
								document.getElementById('participant_container'),
								html`${Object.keys(contractParticipants).map(participant => render.contractChoiceCard(contractParticipants[participant]))}`
							)
						else
							renderElem(
								document.getElementById('participant_container'),
								html`<div>No participants found</div>`
							)
						break;
					case 'continuos-event':
						switch (contractSubtype) {
							case 'tokenswap':
								if (Object.keys(contractParticipants).length)
									renderElem(
										document.getElementById('participant_container'),
										html`${Object.keys(contractParticipants)
											.map(participant => render.participantCard({
												acceptingToken: acceptingToken,
												sellingToken: sellingToken,
												...contractParticipants[participant]
											}))
											}`
									)
								else
									renderElem(
										document.getElementById('participant_container'),
										html`<div>No participants found</div>`
									)
								if (contractDeposits.length)
									renderElem(
										document.getElementById('deposits_container'),
										html`${contractDeposits.map(deposit => render.depositCard({
											...deposit,
											acceptingToken: acceptingToken,
										}))}`
									)
								else
									renderElem(
										document.getElementById('deposits_container'),
										html`<div>No deposits found</div>`
									)
								break;
							default:
								break;
						}
						break;
				}
			} catch (e) {
				console.log(e)
				renderElem(getRef("page_container"), html`${render.errorPage(e)}`);
			}
		})

		router.addRoute('block', async state => {
			const [blockId] = state.wildcards
			if (!blockId) return;
			let [blockInfo, blockTxs] = await Promise.all([getBlockInfo(blockId), getBlockTransactions(blockId)])
			renderElem(getRef("page_container"), html`${render.blockPage(blockInfo)}`);
			getRef("page_title").textContent = 'Block'
			renderTransactions('block_transaction_container', blockTxs)
		})
		router.addRoute('blocks', async state => {
			let allBlocks = await getAllBlocks(100);
			getRef("page_title").textContent = "All Blocks";
			const renderedBlocks = allBlocks.map(block => render.blockCard(block))
			renderElem(getRef("page_container"), html`
						<div id="all_blocks_page" class="page">
							${renderedBlocks}
						</div>
					`)
		})
		router.addRoute('transactions', async state => {
			let allTxs = await getAllTxs();
			getRef("page_title").textContent = "All Transactions";
			renderElem(getRef("page_container"), html`
						<div id="all_transactions_page" class="page"> 
							<ul id="all_transaction_list" class="transaction-container"></ul>	
						</div>
					`)
			renderTransactions('all_transaction_list', allTxs)
		})
		router.addRoute('transaction', async state => {
			try {
				const [txId] = state.wildcards
				if (!txId) return
				const [status, txInfo] = await getTxInfo(txId);
				if (status) {
					renderElem(getRef("page_container"), html`${render.transactionPage(txInfo)}`);
					getRef("page_title").textContent = "transaction";

				} else {
					renderElem(getRef("page_container"), html`${render.errorPage(txInfo)}`);
				}
			} catch (e) {
				console.error(e)
				renderElem(getRef("page_container"), html`${render.errorPage(e)}`);
			}
		})
		router.addRoute('404', state => {
			renderElem(getRef("page_container"), html`${render.errorPage('404 Not Found')}`);
		})
		function loading(show = true) {
			if (show) {
				getRef('loading').classList.remove('hidden')
			} else {
				getRef('loading').classList.add('hidden')
			}
		}
		const slideInLeft = [
			{
				opacity: 0,
				transform: 'translateX(1rem)'
			},
			{
				opacity: 1,
				transform: 'translateX(0)'
			}
		]
		const slideOutLeft = [
			{
				opacity: 1,
				transform: 'translateX(0)'
			},
			{
				opacity: 0,
				transform: 'translateX(-1rem)'
			},
		]
		const slideInRight = [
			{
				opacity: 0,
				transform: 'translateX(-1rem)'
			},
			{
				opacity: 1,
				transform: 'translateX(0)'
			}
		]
		const slideOutRight = [
			{
				opacity: 1,
				transform: 'translateX(0)'
			},
			{
				opacity: 0,
				transform: 'translateX(1rem)'
			},
		]
		const slideInDown = [
			{
				opacity: 0,
				transform: 'translateY(-1rem)'
			},
			{
				opacity: 1,
				transform: 'translateY(0)'
			},
		]
		const slideOutDown = [
			{
				opacity: 1,
				transform: 'translateY(0)'
			},
			{
				opacity: 0,
				transform: 'translateY(1rem)'
			},
		]
		const slideInUp = [
			{
				opacity: 0,
				transform: 'translateY(1rem)'
			},
			{
				opacity: 1,
				transform: 'translateY(0)'
			},
		]
		const slideOutUp = [
			{
				opacity: 1,
				transform: 'translateY(0)'
			},
			{
				opacity: 0,
				transform: 'translateY(-1rem)'
			},
		]
		function showChildElement(id, index, options = {}) {
			return new Promise((resolve) => {
				const { mobileView = false, entry, exit } = options
				const animOptions = {
					duration: floGlobals.prefersReducedMotion ? 0 : 150,
					easing: 'ease',
					fill: 'forwards'
				}
				const parent = typeof id === 'string' ? document.getElementById(id) : id;
				const visibleElement = [...parent.children].find(elem => !elem.classList.contains(mobileView ? 'hide-on-mobile' : 'hidden'));
				if (visibleElement === parent.children[index]) return;
				visibleElement.getAnimations().forEach(anim => anim.cancel())
				parent.children[index].getAnimations().forEach(anim => anim.cancel())
				if (visibleElement) {
					if (exit) {
						parent.style.overflow = 'hidden'
						visibleElement.animate(exit, animOptions).onfinish = () => {
							visibleElement.classList.add(mobileView ? 'hide-on-mobile' : 'hidden')
							parent.style.overflow = ''
						}
						parent.children[index].classList.remove(mobileView ? 'hide-on-mobile' : 'hidden')
						if (entry) {
							parent.children[index].animate(entry, animOptions).onfinish = () => resolve()
						}
					} else {
						visibleElement.classList.add(mobileView ? 'hide-on-mobile' : 'hidden')
						parent.children[index].classList.remove(mobileView ? 'hide-on-mobile' : 'hidden')
						resolve()
					}
				} else {
					parent.children[index].classList.remove(mobileView ? 'hide-on-mobile' : 'hidden')
					parent.children[index].animate(entry, animOptions).onfinish = () => resolve()
				}
			})
		}
	</script>
	<script>
		let frag = document.createDocumentFragment();
		const render = {
			homepage(obj) {
				let { topToken, totalTransactions, walletAddresses, latestBlock } = obj;
				const { height, time } = latestBlock
				return html`
					<div id="homepage" class="page">
						<section id="first_section">
							<div id="highlights">
								<div class="highlight-item">
									<h4 class="label">top token</h4>
									<h2 class="token"><a href=${`#/token/${topToken}`} class="">${topToken}</a> </h2>
								</div>
								<div class="highlight-item">
									<h4 class="label">Total transactions</h4>
									<h2>${totalTransactions}</h2>
								</div>
								<div class="highlight-item">
									<h4 class="label">Wallet addresses</h4>
									<h2>${walletAddresses}</h2>
								</div>
								<div class="highlight-item">
									<h4 class="label">Latest block (${getFormattedTime(time, 'relative')})</h4>
									<h2><a class="block-height" href=${`#/block/${height}`}>${height}</a></h2>
								</div>
							</div>
						</section>
						<section id="latest_transaction_section" class="margin-bottom-2">
							<header class="flex align-center space-between">
								<h3>Recent transactions</h3>
								<a id='all_trans_btn' href=${`#/transactions`} class="button button--small button--colored">View all</a>
							</header>
							<ul id="top_transaction_container" class="transaction-container"> </ul>
						</section>
						<section id="latest_blocks_section">
							<header class="flex align-center space-between">
								<h3>Recent blocks</h3>
								<a id='all_blocks_btn' href=${`#/blocks`} class="button button--small button--colored">View all</a>
							</header>
							<div id="top_blocks_container"> </div>
						</section>
					</div>
				`;
			},
			blockPage(obj) {
				let { blockHeight, size, transactions, reward, hash, difficulty, nonce } = obj;
				return html`
					<div id="block_page" class="page">
						<h5 class="label">Block Height</h5>
						<h2 class="block-height">${blockHeight}</h2>
						<div class="card">
							<h5 class="label">Relevant Transactions</h5>
							<h4>${transactions.length}</h4>
							<h5 class="label">Confirmations</h5>
							<h4>${size}</h4>
							<h5 class="label">Reward</h5>
							<h4>${reward}</h4>
							<h5 class="label">Block Hash</h5>
							<sm-copy value=${hash} clip-text></sm-copy>
							<h5 class="label">Difficulty</h5>
							<h4>${difficulty}</h4>
							<h5 class="label">Nonce</h5>
							<h4>${nonce}</h4>
						</div>
						<h3 class="heading">Transactions</h3>
						<div id="block_transaction_container" class="top-bottom-padding"></div>
					</div>
				`;
			},
			addressPage(obj) {
				let { floBalance, floAddress, ownedTokens = {} } = obj;
				for (const token in ownedTokens) {
					if (!ownedTokens[token].balance)
						ownedTokens[token].balance = 0
				}
				if (!ownedTokens)
					ownedTokens = {}
				return html`
					<div id="address_page" class="page">
						<div class="balance-card">
							<h2 class="wrap-around margin-bottom-2">${floAddress}</h2>
							<h5 class="label">FLO Balance</h5>
							<h3 class="margin-bottom-2">${floBalance} FLO</h3>
							${Object.keys(ownedTokens).length ? html`
								<div class="grid gap-0-5">
									<h5>Tokens</h5>
									<ul id="token_balance_list">
										${Object.keys(ownedTokens).map(token => render.tokenBalanceCard(token, ownedTokens[token].balance))}
									</ul>
								</div>
							`: ''}
						</div>
						<h4>Transactions</h4>
						<ul id="address_transaction_container" class="transaction-container"></ul>
					</div>
				`;
			},
			tokenBalanceCard(token, balance) {
				return html`
				  <li class="token-balance">
					<a href=${`#/token/${token}`} class="label token">${token}</a>
					<h4>${formatAmount(balance, token.toLowerCase() === 'rupee' ? 'inr' : 'usd')}</h4>
				  </li>
				`;
			},
			transactionPage(obj) {
				let { type, name, blockHeight, amount, sender, receiver, floData, hash, confirmations, nftHash } = obj;
				// todo : This is a temporary fix. Fix this on the Database and API level
				if (type == 'smartContractPays' || type == ' smartContractPays') {
					name = ''
				}

				if (type.trim() === 'nftIncorporation')
					type = 'NFT Incorporation'
				else if (type.trim() === 'nft transfer')
					type = 'NFT Transfer'

				return html`
					<div id="transaction_page" class="page">
						<div class='head'>
							<h5 class="label">${type}</h5>
							<h2 class="token uppercase">
								<a href=${`#/token/${name}`} style="text-decoration:none;">${name}</a>
							</h2>
							<h5 class="label">Transaction ID</h5>
							<sm-copy value=${hash} clip-text></sm-copy>
						</div>
						<div class="card grid gap-1-5 align-start align-self-start">
							<div class="flex flex-direction-column">
								<h5 class="label">Block</h5>
								<a href=${`#/block/${blockHeight}`} class="block-height">${blockHeight}</a>
							</div>
							<div class="flex flex-direction-column">
								<h5 class="label">Sender</h5>
								<a href=${`#/address/${sender}`} class="address wrap-around">${sender}</a>
							</div>
							${receiver ? html`
									<div class="flex flex-direction-column">
										<h5 class="label">Receiver</h5>
										<a href=${`#/address/${receiver}`} class="address wrap-around">${receiver}</a>
									</div>
								`: ''
					}
							${amount ? html`
								<div class="flex flex-direction-column">
									<h5 class="label">Amount</h5>
									<h4>${formatAmount(amount, 'usd')}</h4>
								</div>
								`: ''
					}
						</div>
						<div class="card">
							<h5 class="label">FLO Data</h5>
							<p class="wrap-around">${floData}</p>
							<h5 class="label">Block Confirmations</h5>
							<h4>${confirmations}</h4>
							${nftHash ? html`
									<h5 class="label">NFT hash</h5>
									<sm-copy value=${nftHash} clip-text></sm-copy>
								`: ''
					}
						</div>
					</div>
              `;
			},
			errorPage(reason) {
				const page = document.createElement('section')
				page.classList.add('page')
				page.id = 'error_page'
				page.innerHTML = `
					<h1>Not found!</h1>
					<p>${reason}</p>
				`
				return page
			},
			addrBalanceCard(address, balance, token) {
				return html`
				  <li class="flex align-center space-between flex-wrap gap-0-5 holder-balance">
					<a href=${`#/address/${address}`} class="address wrap-around">${address}</a>
                    <span>${formatAmount(balance, token.toLowerCase() === 'rupee' ? 'inr' : 'usd')} ${token}</span>
				  </li>
				`;
			},
			tokenPage(obj) {
				let {
					token,
					supply,
					incAddress
				} = obj;
				return html`
				<div id="token_page" class="page">
					<div class="card">
					<h2 class="uppercase">${token}</h2>
					<h5 class="label">Supply</h5>
					<h4> ${supply ? formatAmount(supply, token.toLowerCase() === 'rupee' ? 'inr' : 'usd') : 'Infinite'} </h4>
					<h5 class="label">Incorporation address</h5>
					<h4 class="wrap-around">${incAddress}</h4>
					</div>
					<sm-chips data-target="token_views" onchange="changeView(event)">
						<sm-chip value="0" selected>Transactions</sm-chip>
						<sm-chip value="1">Token holders</sm-chip>
					</sm-chips>
					<div id="token_views" class="view-wrapper">
						<ul id="token_transaction_container" class="transaction-container"></ul>
						<ul id="token_balance_container" class="hidden"></ul>
					</div>
				</div>
              `;
			},
			contractPage(obj) {
				let {
					status,
					contract,
					contractType,
					contractSubtype,
					contractAddress,
					expiration,
					token,
					participationFees,
					userChoices,
					payeeAddress,
					minAmount,
					maxAmount,
					acceptingToken,
					sellingToken,
					numberOfDeposits,
					numberOfParticipants,
					totalHonorAmount,
					totalParticipationAmount,
					priceType,
					oracle_address,
					price
				} = obj;
				console.log(obj)
				return html`
					<div id="contract_page" class="page">
						${status ? html`
							<div class=${`status ${status}`}>${status}</div>
						`: ''}
                    	<h2 class="uppercase">${replaceDash(contract)}</h2>
						<div id="contract_info" class="card">
							<div class="flex info-row">
								<h5 class="label">Contract Type</h5>
								<h4>${replaceDash(contractType)}</h4>
							</div>
							${contractSubtype ? html`
								<div class="flex info-row">
									<h5 class="label">Contract Subtype</h5>
									<h4>${replaceDash(contractSubtype)}</h4>
								</div>
							` : ''}
							<div class="flex info-row">
								<h5 class="label">Contract Address</h5>
								<a href=${`#/address/${contractAddress}`} class="address wrap-around">${contractAddress}</a>
							</div>
							${expiration ? html`
								<div class="flex info-row">
									<h5 class="label">Expiration</h5>
									<h4>${getFormattedTime(new Date(expiration).getTime())}</h4>
								</div>
							` : ''}
							${payeeAddress ? html`
								<div class="flex info-row">
									<h5 class="label">Payee Addresses</h5>
									<div class="grid gap-0-5">
										${Object.keys(payeeAddress).map(address => html`
											<a href=${`#/address/${address}`} class="address wrap-around">${address}</a>
										`)}
									</div>
								</div>
							`: ''}
							${minAmount ? html`
								<div class="flex info-row">
									<h5 class="label">Min. Subscription Amount</h5>
									<h4>${formatAmount(minAmount, 'usd')} ${token}</h4>
								</div>
							`: ''}
							${maxAmount ? html`
								<div class="flex info-row">
									<h5 class="label">Max. Subscription Amount</h5>
									<h4>${formatAmount(maxAmount, 'usd')} ${token}</h4>
								</div>
							`: ''}
							${participationFees ? html`
								<div class="flex info-row">
									<h5 class="label">Participation Fees</h5>
									<h4>${formatAmount(participationFees, 'usd')} ${token}</h4>
								</div>
							`: ''}
							${contractType === 'one-time-event' ? html`
								<div class="flex info-row">
									<h5 class="label">Token Used</h5>
									<h4>${token}</h4>
								</div>
							`: ''}
							${contractType === 'continuos-event' && contractSubtype === 'tokenswap' ? html`
								<div class="flex info-row">
									<h5 class="label">Input token</h5>
									<h4>${acceptingToken}</h4>
								</div>
								<div class="flex info-row">
									<h5 class="label">Output token</h5>
									<h4>${sellingToken}</h4>	
								</div>
								<div class="flex info-row">
									<h5 class="label">Exchange rate (${priceType === 'dynamic' ? 'Dynamic' : 'Fixed'})</h5>
									<h4>1 ${sellingToken} = ${price} ${acceptingToken}</h4>
								</div>
							`: ''}
							${numberOfDeposits ? html`
								<div class="flex info-row">
									<h5 class="label">Number of deposits</h5>
									<h4>${numberOfDeposits}</h4>
								</div>
							`: ''}
							${numberOfParticipants ? html`
								<div class="flex info-row">
									<h5 class="label">Number of participants</h5>
									<h4>${numberOfParticipants}</h4>
								</div>
							`: ''}
							${oracle_address ? html`
								<div class="flex info-row">
									<h5 class="label">Oracle address</h5>
									<a href=${`#/address/${oracle_address}`} class="address wrap-around">${oracle_address}</a>
								</div>
							`: ''}
							${totalParticipationAmount ? html`
								<div class="flex info-row">
									<h5 class="label">Total participation amount</h5>
									<h4>${formatAmount(totalParticipationAmount, 'usd')} ${acceptingToken}</h4>
								</div>
							`: ''}
							${totalHonorAmount ? html`
								<div class="flex info-row">
									<h5 class="label">Total output amount</h5>
									<h4>${formatAmount(totalHonorAmount, 'usd')} ${sellingToken}</h4>
								</div>
							`: ''}
						</div>
						${userChoices ? html`
							<h3>Available Choices</h3>
							<ul type="circle" class="card">
								${Object.keys(userChoices).map(choice => html`
									<li>${userChoices[choice]}</li>
								`)}
							</ul>
						`: ''}
						<sm-chips class="margin-top-1" data-target="contract_views" onchange="changeView(event)">
							<sm-chip value="0" selected>Transactions</sm-chip>
							<sm-chip value="1">Participants</sm-chip>
							${contractType === 'one-time-event' && contractSubtype === 'external-trigger' ? html`<sm-chip value="2">Winners</sm-chip>` : ''}
							${contractType === 'continuos-event' && contractSubtype === 'tokenswap' ? html`<sm-chip value="2">Deposits</sm-chip>` : ''}
						</sm-chips>
						<div id="contract_views" class="view-wrapper">
							<div id="contract_transaction_container" class="transaction-container"></div>
							<ul id="participant_container" class="card hidden"></ul>
							${contractType === 'one-time-event' && contractSubtype === 'external-trigger' ? html`<ul id="winners_container" class="card hidden"></ul>` : ''}
							${contractType === 'continuos-event' && contractSubtype === 'tokenswap' ? html`<ul id="deposits_container" class="card hidden"></ul>` : ''}
						</div>
					</div>
				`;
			},
			participantCard(details) {
				const { participantFloAddress, participationAmount, swapAmount, swapPrice, transactionHash, acceptingToken, sellingToken } = details;
				return html`
					<li class="flex participant">
						<div class="grid gap-0-5 flex-1">
							<div class="flex align-center gap-0-5">
								<svg class="icon" xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 0 24 24" width="24px" fill="#000000"><path d="M0 0h24v24H0V0z" fill="none"/><path d="M6.99 11L3 15l3.99 4v-3H14v-2H6.99v-3zM21 9l-3.99-4v3H10v2h7.01v3L21 9z"/></svg>
								<h5>Token swap</h5>
							</div>	
							<a href=${`#/address/${participantFloAddress}`} class="address wrap-around">${participantFloAddress}</a> 
						</div>
						<div class="grid align-center gap-1 flex-1" style="grid-template-columns: repeat(auto-fill, minmax(8rem, 1fr))">
							<div>
								<h5 class="label">Input amount</h5>
								<b>${formatAmount(participationAmount, 'usd')} ${acceptingToken}</b>
							</div>
							<div>
								<h5 class="label">Output amount</h5>
								<b>${formatAmount(swapAmount, 'usd')} ${sellingToken}</b>
							</div>
							<div>
								<h5 class="label">Exchange rate</h5>
								<b>${formatAmount(swapPrice, 'usd')} ${acceptingToken}</b>
							</div>
						</div>
					</li>
				`;
			},
			depositCard(details) {
				const { currentBalance, depositorAddress, originalBalance, status, time, transactionHash, acceptingToken } = details
				return html`
				<li class="flex deposit-card">
					<div class="grid gap-0-5 flex-1">
						<h5>Deposit</h5>
						<a href=${`#/address/${depositorAddress}`} class="address wrap-around">${depositorAddress}</a> 
					</div>
					<div class="grid align-center gap-1 flex-1" style="grid-template-columns: repeat(auto-fill, minmax(8rem, 1fr))">
						<div>
							<h5 class="label">Deposited</h5>
							<b>${formatAmount(originalBalance, 'usd')} ${acceptingToken}</b>
						</div>
						<div>
							<h5 class="label">Current balance</h5>
							<b>${formatAmount(currentBalance, 'usd')} ${acceptingToken}</b>
						</div>
						<div>
							<h5 class="label">Status</h5>
							<b>${status}</b>
						</div>
					</div>
				</li>
				`
			},
			contractChoiceCard(details) {
				const { participantFloAddress, userChoice, tokenAmount, transactionHash, winningAmount } = details;
				let action;
				if (winningAmount) {
					action = 'Won'
					amount = winningAmount
				} else
					action = 'Invested'
				return html`
					<li class="contract-choice">
						<a href=${`#/address/${participantFloAddress}`} class="address wrap-around">${participantFloAddress}</a>
						<h4>${userChoice}</h4>
						<h4>${formatAmount(tokenAmount, 'usd')} ${action}</h4>
					</li>
				`;
			},
			contractTransferCard(obj) {
				const { hash, token, sender, receiver, amount, contractName, userChoice, time } = obj;
				return html`
					<li id=${hash} class="transaction token-transfer">
						<svg class="icon" viewBox="0 0 64 64"> <title>contract</title> <path d="M4.75,49.27A8,8,0,0,0,4.2,61.14a7.82,7.82,0,0,0,4.34,2.24,7.42,7.42,0,0,0,1.34.12H47.41a8.06,8.06,0,0,0,8.05-8V7.87"/> <path d="M8.54,56.13V8.54a8.06,8.06,0,0,1,8.05-8H54.12a7.42,7.42,0,0,1,1.34.12A7.82,7.82,0,0,1,59.8,2.86a8,8,0,0,1-.55,11.87"/> <line x1="17.93" y1="22.62" x2="46.07" y2="22.62"/> <line x1="17.93" y1="32" x2="46.07" y2="32"/> <line x1="17.93" y1="41.38" x2="38.03" y2="41.38"/> </svg>
						<div class="contract-type">
							<h5 class="label">Smart Contract Transfer</h5>
							<a href=${`#/token/${token}`} class="">${token}</a>
						</div>
						<div class="contract-info">
							<time>${getFormattedTime(time)}</time>
							<div class="flex flex-direction-column">
								<h5 class="label">Amount</h5>
								<h4>${formatAmount(amount, token.toLowerCase() === 'rupee' ? 'inr' : 'usd')} ${token}</h4>
							</div>
							<div class="flex flex-direction-column">
								<h5 class="label">Contract name</h5>
								<h4>${contractName}</h4>
							</div>
							<div class="flex align-center space-between flex-wrap gap-1">
								<div class="flex flex-direction-column">
									<h5 class="label">Transaction ID</h5>
									<sm-copy value=${hash} clip-text></sm-copy>
								</div>
								<a href=${`#/transaction/${hash}`} class="button button--small button--colored">View details</a>
							</div>
						</div>
					</li>`;
			},
			tokenTransferCard(obj) {
				const { hash, blockHeight, token, sender, receiver, amount, type, time } = obj;
				let title = 'Token transfer';
				if (type === 'nfttransfer')
					title = 'NFT transfer';
				return html`
					<li id=${hash} class="transaction token-transfer">
						<svg class="icon" viewBox="0 0 64 64"> <title>transfer</title> <polyline points="17.04 35.97 14.57 33.5 40.15 7.9 32.75 0.5 55.52 0.5 55.52 23.28 48.12 15.87 23.86 40.14 15.88 48.13 8.48 40.72 8.48 63.5 31.25 63.5 23.85 56.1 49.43 30.5 46.96 28.03"/> </svg>
						<div class="contract-type">
							<h5 class="label">${title}</h5>
							<a href=${`#/token/${token}`} class="">${token}</a>
						</div>
						<div class="contract-info">						
							<time>${getFormattedTime(time)}</time>
							<div class="flex flex-wrap gap-1">	
								<div class="flex flex-direction-column">
									<h5 class="label">Sender</h5>
									<a href=${`#/address/${sender}`} class="address wrap-around">${sender}</a> 
								</div>
								<div class="flex flex-direction-column">
									<h5 class="label">Receiver</h5>
									<a href=${`#/address/${receiver}`} class="address wrap-around">${receiver}</a> 
								</div>
							</div>
							<div class="flex flex-direction-column">
								<h5 class="label">Amount</h5>
								<h4>${formatAmount(amount, token.toLowerCase() === 'rupee' ? 'inr' : 'usd')} ${token}</h4>
							</div>
							<div class="flex align-center space-between flex-wrap gap-1">
								<div class="flex flex-direction-column">
									<h5 class="label">Transaction ID</h5>
									<sm-copy value=${hash} clip-text></sm-copy>
								</div>
								<a href=${`#/transaction/${hash}`} class="button button--small button--colored">View details</a>
							</div>
						</div>
					</li>
				`;
			},
			tokenCreationCard(obj) {
				const { hash, blockHeight, token, incAddress, supply, type, nftHash, time } = obj;
				let title = 'Token creation';
				if (type === 'nftincorp')
					title = 'NFT creation';
				return html`
					<li id=${hash} class="transaction token-creation">
						<svg class="icon" viewBox="0 0 64 64"> <title>token</title> <circle cx="32" cy="32" r="31"/> <circle cx="32" cy="32" r="25.19"/> <line x1="37" y1="21.74" x2="43.14" y2="21.74"/> <path d="M20.86,21.74H32V43.23"/> </svg>
						<div class="contract-type">
							<h5 class="label">${title}</h5>
							<a href=${`#/token/${token}`} class="token uppercase">${token}</a>
						</div>
						<div class="contract-info">
							<time>${getFormattedTime(time)}</time>
							<div class="flex flex-direction-column">
								<h5 class="label">Incorporation address</h5>
								<a href=${`#/address/${incAddress}`} class="address wrap-around">${incAddress}</a>
							</div>
							<div class="flex flex-direction-column">
								<h5 class="label">token name</h5>
								<h4 class="uppercase">${token}</h4>
							</div>
							<div class="flex flex-direction-column">
								<h5 class="label">supply</h5>
								<h4>${supply}</h4>
							</div>
							${type === 'nftincorp' ? html`<div class="flex flex-direction-column">
									<h5 class="label">NFT hash</h5>
									<sm-copy value="${nftHash}"></sm-copy>
								</div>`: ''
					}
							<div class="flex align-center space-between flex-wrap gap-1">
								<div class="flex flex-direction-column">
									<h5 class="label">Transaction ID</h5>
									<sm-copy value=${hash} clip-text></sm-copy>
								</div>
								<a href=${`#/transaction/${hash}`} class="button button--small button--colored">View details</a>
							</div>
						</div>
					</li>`;
			},
			contractTriggerCard(obj) {
				const { hash, blockHeight, contractName, contractAddress, winningChoice, committeeAddress, time } = obj;
				return html`
					<li id=${hash} class="transaction contract-trigger">
						<svg class="icon" viewBox="0 0 64 64"> <circle cx="32" cy="32" r="31"/> <polyline points="32 13.47 32 32 43.4 43.4"/> </svg>
						<div class="contract-type">
							<h5 class="label">smart contract </h5>
							<h4 class="uppercase">trigger</h4>
						</div>
						<div class="contract-info">
							<time>${getFormattedTime(time)}</time>
							<div class="flex flex-direction-column">
								<h5 class="label">Contract name</h5>
								<h4>${contractName}</h4>
							</div>
							<div class="flex flex-direction-column">
								<h5 class="label">contract address</h5>
								<a href=${`#/address/${contractAddress}`} class="address wrap-around">${contractAddress}</a>
							</div>
							<div class="flex flex-direction-column">
								<h5 class="label">Winning Choice</h5>
								<h4>${winningChoice}</h4>
							</div>
							<div class="flex flex-direction-column">
								<h5 class="label">committee address</h5>
								<a href=${`#/address/${committeeAddress}`} class="address wrap-around">${committeeAddress}</a>
							</div>
							<div class="flex align-center space-between flex-wrap gap-1">
								<div class="flex flex-direction-column">
									<h5 class="label">Transaction ID</h5>
									<sm-copy value=${hash} clip-text></sm-copy>
								</div>
								<a href=${`#/transaction/${hash}`} class="button button--small button--colored">View details</a>
							</div>
						</div>
					</li>
				`;
			},
			contractCreationCard(obj) {
				const { hash, blockHeight, token, contractName, incAddress, contractType, expiration, participationFees, availableChoices, time } = obj;
				console.log(obj);
				return html`
					<li id=${hash} class="transaction contract-creation">
						<svg class="icon" viewBox="0 0 64 64"> <title>contract creation</title> <path d="M47.07,23.85V11"/> <path d="M3,47A7,7,0,0,0,.48,52.39a6.89,6.89,0,0,0,2.05,4.93,6.78,6.78,0,0,0,3.78,2,6.34,6.34,0,0,0,1.16.1H40.09a7,7,0,0,0,7-7V44"/> <path d="M6.31,53V11.61a7,7,0,0,1,7-7H45.91a6.26,6.26,0,0,1,1.16.1,6.74,6.74,0,0,1,3.78,1.95A7,7,0,0,1,50.37,17"/> <line x1="14.46" y1="23.85" x2="38.92" y2="23.85"/> <line x1="14.46" y1="32" x2="38.92" y2="32"/> <line x1="14.46" y1="40.15" x2="31.93" y2="40.15"/> <path d="M57.79,24.44l-2.88-2.9,3.79-3.79a1,1,0,0,1,1.39,0l3.11,3.11a1,1,0,0,1,0,1.39L40.34,45.1a1,1,0,0,1-.52.28L36,46A1,1,0,0,1,34.9,44.9l.67-3.77a1,1,0,0,1,.27-.52L52.65,23.8"/> </svg>
						<div class="contract-type">
							<h5 class="label">Smart Contract creation</h5>
							<a href=${`#/token/${token}`} class="">${token}</a>
						</div>
						<div class="contract-info">
							<time>${getFormattedTime(time)}</time>
							<div class="flex flex-direction-column">
								<h5 class="label">Contract name</h5>
								<h4>${contractName}</h4>
							</div>
							<div class="flex flex-direction-column">
								<h5 class="label">Contract address</h5>
								<a href=${`#/address/${incAddress}`} class="address wrap-around">${incAddress}</a>
							</div>
							<div class="flex flex-direction-column">
								<h5 class="label">token used</h5>
								<h4>${token}</h4>
							</div>
							<div class="flex flex-direction-column">
								<h5 class="label">contract type</h5>
								<h4>${replaceDash(contractType)}</h4>
							</div>
							${expiration ? html`
								<div class="flex flex-direction-column">
									<h5 class="label">expiration</h5>
									<h4 class="capitalise">${getFormattedTime(new Date(expiration).getTime())}</h4>
								</div>`: ''}
							<div class="flex flex-direction-column">
								<h5 class="label">participation amount</h5>
								<h4>${participationFees} ${token}</h4>
							</div>
							<div class="flex align-center space-between flex-wrap gap-1">
								<div class="flex flex-direction-column">
									<h5 class="label">Transaction ID</h5>
									<sm-copy value=${hash} clip-text></sm-copy>
								</div>
								<a href=${`#/transaction/${hash}`} class="button button--small button--colored">View details</a>
							</div>
						</div>
					</li>`;
			},
			blockCard(blockDetails) {
				const { height, tx, time } = blockDetails;
				const plural = parseInt(tx.length) > 1 ? 's' : '';
				return html`
					<div class="block-card grid align-center">
						<a href=${`#/block/${height}`} class="block-height">${height}</a>
          				<span>${tx.length} Transaction${plural}</span>
						<time>${getFormattedTime(time, 'relative')}</time>
					</div>
				`;
			}
		};

		function replaceDash(string) {
			return string.replace(/-/g, " ");
		}

		function replaceSpace(str) {
			return str.replace(/ /g, "-");
		}

		async function renderTransactions(container, transactions = []) {
			let txFrag = parseTransactions(transactions);
			const renderedTransactions = txFrag.map(tx => {
				switch (tx.type) {
					case 'tokentransfer':
					case 'nfttransfer':
						return render.tokenTransferCard(tx)
						break;
					case 'contracttransfer':
						return render.contractTransferCard(tx);
						break;
					case 'tokenincorp':
					case 'nftincorp':
						return render.tokenCreationCard(tx);
						break;
					case 'contractincorp':
						return render.contractCreationCard(tx);
						break;
					case 'contracttrigger':
						return render.contractTriggerCard(tx);
						break;
				}
			})
			renderElem(document.getElementById(container), html`${renderedTransactions.length ? renderedTransactions : html`<div class="no-results">No transactions found</div>`}`)
		}

		getRef('suggestions').addEventListener('keyup', e => {
			if (e.target.closest('.suggestion') && e.key === 'Enter') {
				processNavbarSearch()
			} else if (e.target.closest('.suggestion') && e.key === 'Tab') {
				getRef('main_search_field').value = e.target.textContent;
			}
		})
		getRef('main_search_field').addEventListener('input', debounce(e => {
			let results = flexSearch.search(e.target.value, 25)
			const renderedSuggestions = results.map(suggestionIndex => {
				return html`
					<li class="suggestion wrap-around" tabindex="0">
						${allSuggestions[suggestionIndex]}
					</li>
				`
			})
			renderElem(getRef('suggestions'), html`${renderedSuggestions}`)
		}, 100))
		async function getBannerData() {
			const { systemTransactionCount, systemAddressCount } = await fetchJson(`${floGlobals.tokenApiUrl}/api/v2/info`)
			return {
				topToken: "RMT",
				totalTransactions: systemTransactionCount,
				walletAddresses: systemAddressCount,
			}
		}
		let currentViewIndex = 0;
		function changeView(e) {
			const targetWrapper = e.target.dataset.target;
			const viewIndex = parseInt(e.target.value);
			showChildElement(targetWrapper, viewIndex, { entry: viewIndex > currentViewIndex ? slideInLeft : slideInRight, exit: viewIndex > currentViewIndex ? slideOutLeft : slideOutRight });
			currentViewIndex = viewIndex;
		}

		function getLatestTxs() {
			return new Promise((resolve, reject) => {
				fetchJson(`${floGlobals.tokenApiUrl}/api/v2/latestTransactionDetails?limit=4`)
					.then(function (latestTxs) {
						resolve(latestTxs.latestTransactions)
					}).catch((err) => {
						reject(err)
					});
			})
		}

		function getTokenInfo(thisToken) {
			return new Promise((resolve, reject) => {
				fetchJson(
					`${floGlobals.tokenApiUrl}/api/v2/tokenInfo/${thisToken.toLowerCase()}`
				).then(function (tokenInfo) {
					if (tokenInfo.result === "error")
						reject(tokenInfo.description);
					let associatedSC = {};
					tokenInfo.associatedSmartContracts.forEach((sc) => {
						associatedSC[`${sc.contractName}-${sc.contractAddress}`] = sc;
					});
					resolve({
						token: tokenInfo["token"],
						supply: tokenInfo["tokenSupply"],
						incAddress: tokenInfo["incorporationAddress"],
						associatedContracts: associatedSC,
						blockchainReference: tokenInfo["blockchainReference"],
					});
				}).catch((err) => {
					reject(err);
				});
			})
		}

		async function getTokenBalances(tokenName) {
			const tokenDetails = await fetchJson(`${floGlobals.tokenApiUrl}/api/v2/tokenBalances/` + tokenName)
			return tokenDetails.balances
		}

		async function getTokenTransactions(tokenName) {
			const transactions = await fetchJson(`${floGlobals.tokenApiUrl}/api/v2/tokenTransactions/` + tokenName)
			return transactions.transactions
		}

		async function getBlockInfo(thisBlock) {
			const info = await fetchJson(`${floGlobals.tokenApiUrl}/api/v2/blockDetails/${thisBlock}`);
			const { height, size, reward, hash, difficulty, nonce, tx } = info.blockDetails
			return {
				blockHeight: height,
				size: size,
				transactions: tx,
				reward: reward,
				hash: hash,
				difficulty: difficulty,
				nonce: nonce,
			}
		}

		async function getBlockTransactions(thisBlock) {
			const blockTransactions = await fetchJson(`${floGlobals.tokenApiUrl}/api/v2/blockTransactions/${thisBlock}`)
			return blockTransactions.transactions
		}

		async function getContractInfo(contract) {
			const info = await fetchJson(`${floGlobals.tokenApiUrl}/api/v2/smartContractInfo?contractName=${contract.name}&contractAddress=${contract.address}`);
			console.log(info, contract)
			const {
				contractInfo: {
					contractType,
					numberOfDeposits,
					numberOfParticipants,
					priceType,
					oracle_address,
					contractSubtype,
					status,
					expiryTime,
					payeeAddress,
					userChoices,
					tokenIdentification,
					acceptingToken,
					sellingToken,
					contractAmount,
					minimumsubscriptionamount,
					maximumsubscriptionamount,
					totalHonorAmount,
					totalParticipationAmount,
					price
				}, contractAddress,
				contractName
			} = info
			return {
				contract: contractName,
				contractAddress,
				contractType,
				contractSubtype,
				status,
				expiration: expiryTime,
				payeeAddress,
				userChoices,
				token: tokenIdentification,
				acceptingToken,
				sellingToken,
				participationFees: contractAmount,
				minAmount: minimumsubscriptionamount,
				maxAmount: maximumsubscriptionamount,
				numberOfDeposits,
				numberOfParticipants,
				priceType,
				oracle_address,
				totalHonorAmount,
				totalParticipationAmount,
				price
			}
		}

		async function getContractParticipants(contract) {
			const participants = await fetchJson(`${floGlobals.tokenApiUrl}/api/v2/smartContractParticipants?contractName=${contract.name}&contractAddress=${contract.address}`)
			return participants.participantInfo
		}

		async function getContractTransactions(contract) {
			const transactions = await fetchJson(`${floGlobals.tokenApiUrl}/api/v2/smartContractTransactions?contractName=${contract.name}&contractAddress=${contract.address}`)
			return transactions.contractTransactions
		}

		async function getContractDeposits(contract) {
			console.log(`${floGlobals.tokenApiUrl}/api/v2/smartContractDeposits?contractName=${contract.name}&contractAddress=${contract.address}`)
			const deposits = await fetchJson(`${floGlobals.tokenApiUrl}/api/v2/smartContractDeposits?contractName=${contract.name}&contractAddress=${contract.address}`)
			return deposits.depositInfo
		}

		function parseTransactions(txList) {
			if (!Array.isArray(txList))
				txList = Object.values(txList)
			let latestTxArray = [];
			txList.forEach(tx => {
				const {
					transactionDetails: {
						txid, blockHeight, vin, vout, time },
					parsedFloData: {
						contractAddress,
						contractType,
						contractConditions: { expiryTime } = {},
						contractAmount,
						type,
						tokenAmount,
						tokenIdentification,
						transferType,
						contractName,
						triggerCondition,
						userChoice,
						nftHash
					}
				} = tx;
				let obj = {
					hash: txid,
					blockHeight,
					time
				};
				if (type != "smartContractPays") {
					// determine token
					obj["token"] = tokenIdentification;
					switch (type) {
						case 'transfer':
							if (transferType == "token" || transferType == 'nft') {
								let receiverAddress = "";
								for (const output of vout) {
									if (output["scriptPubKey"]["addresses"][0] !== vin[0]["addr"]) {
										receiverAddress = output["scriptPubKey"]["addresses"][0];
										break;
									}
								}

								obj = Object.assign({}, obj, {
									sender: vin[0]["addr"],
									receiver: receiverAddress,
									amount: tokenAmount,
									type: transferType == "token" ? "tokentransfer" : "nfttransfer",
								});
								latestTxArray.push(obj);
								break;
							} else if (transferType == 'smartContract') {
								// smart contract transfer
								let receiverAddress = "";
								for (const output of vout) {
									if (output["scriptPubKey"]["addresses"][0] !== vin[0]["addr"]) {
										receiverAddress = output["scriptPubKey"]["addresses"][0];
										break;
									}
								}

								obj = Object.assign({}, obj, {
									sender: vin[0]["addr"],
									receiver: receiverAddress,
									amount: tokenAmount,
									contractName,
									userChoice,
									type: "contracttransfer",
								});
								latestTxArray.push(obj);
								break;
							}
						case 'tokenIncorporation':
							// token incorporation
							// smart contract incorporation
							obj = Object.assign({}, obj, {
								incAddress: vin[0]["addr"],
								supply: tokenAmount,
								type: "tokenincorp",
							});
							latestTxArray.push(obj);
							break;
						case 'smartContractIncorporation':
							// smart contract incorporation
							// todo : add checks to determine obj for different types of smart contract incorporation
							obj = Object.assign({}, obj, {
								contractName,
								incAddress: contractAddress,
								contractType,
								expiration: expiryTime,
								participationFees: contractAmount,
								availableChoices: "",
								type: "contractincorp",
							});
							latestTxArray.push(obj);
							break;
						case 'nftIncorporation':
							// nft incorporation
							obj = Object.assign({}, obj, {
								incAddress: vin[0]["addr"],
								supply: tokenAmount,
								type: "nftincorp",
								nftHash
							});
							latestTxArray.push(obj);
							break;
					}

				} else {
					// transaction is a FLO Smart Contract Committee trigger

					let receiver = "", sender = vin[0]['addr'];
					for (const output of vout) {
						if (output["scriptPubKey"]["addresses"][0] !== vin[0]["addr"]) {
							receiverAddress = output["scriptPubKey"]["addresses"][0];
							break;
						}
					}

					obj = Object.assign({}, obj, {
						hash: txid,
						blockHeight,
						contractName,
						contractAddress: receiver,
						winningChoice: triggerCondition,
						committeeAddress: sender,
						type: 'contracttrigger'
					});
					latestTxArray.push(obj);
				}
			})

			return latestTxArray;
		}

		async function getAllBlocks(number) {
			const allBlocks = await fetchJson(`${floGlobals.tokenApiUrl}/api/v2/latestBlockDetails${number ? `?limit=${number}` : ''}`)
			return Object.values(allBlocks.latestBlocks).sort((a, b) => b.height - a.height)
		}

		async function getAllTxs() {
			const allTxs = await fetchJson(`${floGlobals.tokenApiUrl}/api/v2/latestTransactionDetails?limit=200`)
			return allTxs.latestTransactions
		}

		async function getAddressInfo(floAddress) {
			const addressInfo = await fetchJson(`${floGlobals.tokenApiUrl}/api/v2/floAddressInfo/${floAddress}`)
			return addressInfo.floAddressBalances
		}

		async function getAddressBalance(floAddress) {
			return await fetchJson(`${floGlobals.floApiUrl}/api/addr/${floAddress}/balance`)
		}

		async function getAddressTxs(floAddress) {
			const transactions = await fetchJson(`${floGlobals.tokenApiUrl}/api/v2/floAddressTransactions/${floAddress}`)
			return transactions.transactions
		}

		async function getTxInfo(thisTx) {
			try {
				const transaction = await fetchJson(`${floGlobals.tokenApiUrl}/api/v2/transactionDetails/${thisTx}`)
				if (transaction.result === 'error') {
					return [false, transaction.description]
				} else {
					let transactionHash = transaction.transactionHash,
						{ flodata, tokenAmount, tokenIdentification, type, nftHash } = transaction.parsedFloData,
						{ blockheight, vin, vout, confirmations } = transaction.transactionDetails;
					let sender = vin[0].addr;
					let receiver = sender
					for (let i = 0; i < vout.length; i++) {
						if (vout[i]["scriptPubKey"]["addresses"][0] !== vin[0]["addr"]) {
							receiver = vout[i]["scriptPubKey"]["addresses"][0];
						}
					}
					console.log(transaction)
					// todo - temporary fixes below. Fix these on the Database and API level
					let transactionType = ''
					if (type == 'transfer') {
						transactionType = transaction.parsedFloData?.transferType
					}
					if (type == 'smartContractPays') {
						tokenAmount = '-'
						flodata = transaction.transactionDetails.floData
					}
					return [
						true, {
							type: `${transactionType} ${type}`,
							name: tokenIdentification,
							blockHeight: blockheight,
							amount: tokenAmount,
							sender,
							receiver,
							floData: flodata,
							hash: transactionHash,
							confirmations,
							nftHash
						}
					]
				}
			}
			catch (err) {
				console.error(err)
			}
		}


		function returnHexNumber(s) {
			var regExp = /^[-+]?[0-9A-Fa-f]+\.?[0-9A-Fa-f]*?$/;
			return (typeof s === 'string' && regExp.test(s));
		}

		function isInt(n) {
			return Number(n) === n && n % 1 === 0;
		}

		function isFloat(n) {
			return Number(n) === n && n % 1 !== 0;
		}

		function splitContractNameAddress(text) {
			const index = text.lastIndexOf('-');
			return {
				name: text.substring(0, index),
				address: text.substring(index + 1)
			};
		}

		function categorizeText(text) {
			return new Promise((resolve, reject) => {
				// check if text have only numbers
				if (/^\d+$/.test(text)) {
					//console.log('this is a block number');
					location.href = `#/block/${text}`
					resolve('block')
				} else if (text.length == 34 && floCrypto.validateFloID(text)) {
					//console.log('data entered is a FLO address');
					location.href = `#/address/${text}`
					resolve('address')
				} else if (window.ranchimallFlo.tokenList.includes(text.toLowerCase())) {
					//console.log('data entered is a token name');
					location.href = `#/token/${text}`
					resolve('token')
				} else if (window.ranchimallFlo.smartContractNameAddressList.includes(text)) {
					location.href = `#/contract/${text}`
					resolve('contract')
				} else if (text.length == 64 && returnHexNumber(text)) {
					fetchJson(`${floGlobals.tokenApiUrl}/api/v2/categoriseString/` + text)
						.then(function (myJson) {
							console.log(`${floGlobals.tokenApiUrl}/api/v2/categoriseString/` + text)
							if (myJson['type'] == 'transaction') {
								//console.log('data entered is a transaction hash');
								location.href = `#/transaction/${text}`
							} else if (myJson['type'] == 'block') {
								// console.log('data entered is a block hash');
								location.href = `#/block/${text}`
							} else {
								//console.log('data entered is noise');
							}
							resolve()
						}).catch(err => {
							console.error(err)
							resolve()
						})

				} else {
					//console.log('data entered is noise')
				}
			})
		}

		function processNavbarSearch() {
			const query = getRef('main_search_field').value.trim();
			if (query === '') return
			categorizeText(query).then(() => {
				getRef('main_search_field').value = ''
				renderElem(getRef('suggestions'), html``)
			})
		}

		async function getAllSuggestions() {
			window.allSuggestions = [];
			window.ranchimallFlo = {};
			let { tokens, smartContracts } = await fetchJson(`${floGlobals.tokenApiUrl}/api/v2/tokenSmartContractList`);
			//console.log('first line of the fetch result');
			ranchimallFlo.tokenList = tokens;
			ranchimallFlo.smartContractList = smartContracts;
			ranchimallFlo.smartContractNameList = [];
			ranchimallFlo.smartContractNameAddressList = [];
			//console.log(ranchimallFlo.smartContractList.length);
			ranchimallFlo.smartContractList.forEach(contract => {
				allSuggestions.push(`${contract.contractName}-${contract.contractAddress}`);
				ranchimallFlo.smartContractNameList.push(contract.contractName);
				ranchimallFlo.smartContractNameAddressList.push(`${contract.contractName}-${contract.contractAddress}`);
			})
			ranchimallFlo.tokenList.forEach(token => allSuggestions.push(token));
			flexSearch = new FlexSearch({
				encode: "advanced",
				tokenize: "reverse",
				suggest: true
			});

			allSuggestions.forEach((suggestion, index) => {
				flexSearch.add(index, suggestion);
			})
		}

	</script>

	<!-- Flex search content -->
	<script>
		/*
			FlexSearch v0.6.22
			Copyright 2019 Nextapps GmbH
			Author: Thomas Wilkerling
			Released under the Apache 2.0 Licence
			https://github.com/nextapps-de/flexsearch
		*/
		//FlexSearch min mode
		DEBUG = true;
		'use strict';
		(function (I, R, v) { let K; (K = v.define) && K.amd ? K([], function () { return R }) : (K = v.modules) ? K[I.toLowerCase()] = R : "object" === typeof exports ? module.exports = R : v[I] = R })("FlexSearch", function ma(I) { function v(a, b) { const c = b ? b.id : a && a.id; this.id = c || 0 === c ? c : na++; this.init(a, b); fa(this, "index", function () { return this.a ? Object.keys(this.a.index[this.a.keys[0]].c) : Object.keys(this.c) }); fa(this, "length", function () { return this.index.length }) } function K(a, b, c, d) { this.u !== this.g && (this.o = this.o.concat(c), this.u++, d && this.o.length >= d && (this.u = this.g), this.u === this.g && (this.cache && this.l.set(b, this.o), this.F && this.F(this.o))); return this } function S(a) { const b = B(); for (const c in a) if (a.hasOwnProperty(c)) { const d = a[c]; b[c] = E(d) ? d.slice(0) : J(d) ? S(d) : d } return b } function W(a, b) { const c = a.length, d = O(b), e = []; for (let f = 0, g = 0; f < c; f++) { const h = a[f]; if (d && b(h) || !d && !b[h]) e[g++] = h } return e } function P(a, b, c, d, e, f, g, h, l, m) { c = ha(c, g ? 0 : e, h, f, b, l, m); let n; h && (h = c.page, n = c.next, c = c.result); if (g) b = this.where(g, null, e, c); else { b = c; c = this.h; e = b.length; f = Array(e); for (g = 0; g < e; g++) f[g] = c[b[g]]; b = f } c = b; d && (O(d) || (L = d.split(":"), 1 < L.length ? d = oa : (L = L[0], d = pa)), c.sort(d)); c = T(h, n, c); this.cache && this.l.set(a, c); return c } function fa(a, b, c) { Object.defineProperty(a, b, { get: c }) } function q(a) { return new RegExp(a, "g") } function Q(a, b) { for (let c = 0; c < b.length; c += 2) a = a.replace(b[c], b[c + 1]); return a } function V(a, b, c, d, e, f, g, h) { if (b[c]) return b[c]; e = e ? (h - (g || h / 1.5)) * f + (g || h / 1.5) * e : f; b[c] = e; e >= g && (a = a[h - (e + .5 >> 0)], a = a[c] || (a[c] = []), a[a.length] = d); return e } function ba(a, b) { if (a) { const c = Object.keys(a); for (let d = 0, e = c.length; d < e; d++) { const f = c[d], g = a[f]; if (g) for (let h = 0, l = g.length; h < l; h++) if (g[h] === b) { 1 === l ? delete a[f] : g.splice(h, 1); break } else J(g[h]) && ba(g[h], b) } } } function ca(a) { let b = "", c = ""; var d = ""; for (let e = 0; e < a.length; e++) { const f = a[e]; if (f !== c) if (e && "h" === f) { if (d = "a" === d || "e" === d || "i" === d || "o" === d || "u" === d || "y" === d, ("a" === c || "e" === c || "i" === c || "o" === c || "u" === c || "y" === c) && d || " " === c) b += f } else b += f; d = e === a.length - 1 ? "" : a[e + 1]; c = f } return b } function qa(a, b) { a = a.length - b.length; return 0 > a ? 1 : a ? -1 : 0 } function pa(a, b) { a = a[L]; b = b[L]; return a < b ? -1 : a > b ? 1 : 0 } function oa(a, b) { const c = L.length; for (let d = 0; d < c; d++) a = a[L[d]], b = b[L[d]]; return a < b ? -1 : a > b ? 1 : 0 } function T(a, b, c) { return a ? { page: a, next: b ? "" + b : null, result: c } : c } function ha(a, b, c, d, e, f, g) { let h, l = []; if (!0 === c) { c = "0"; var m = "" } else m = c && c.split(":"); const n = a.length; if (1 < n) { const y = B(), r = []; let w, x; var p = 0, k; let G; var u = !0; let C, D = 0, N, da, X, ea; m && (2 === m.length ? (X = m, m = !1) : m = ea = parseInt(m[0], 10)); if (g) { for (w = B(); p < n; p++) if ("not" === e[p]) for (x = a[p], G = x.length, k = 0; k < G; k++) w["@" + x[k]] = 1; else da = p + 1; if (H(da)) return T(c, h, l); p = 0 } else N = M(e) && e; let Y; for (; p < n; p++) { const ra = p === (da || n) - 1; if (!N || !p) if ((k = N || e && e[p]) && "and" !== k) if ("or" === k) Y = !1; else continue; else Y = f = !0; x = a[p]; if (G = x.length) { if (u) if (C) { var t = C.length; for (k = 0; k < t; k++) { u = C[k]; var A = "@" + u; g && w[A] || (y[A] = 1, f || (l[D++] = u)) } C = null; u = !1 } else { C = x; continue } A = !1; for (k = 0; k < G; k++) { t = x[k]; var z = "@" + t; const Z = f ? y[z] || 0 : p; if (!(!Z && !d || g && w[z] || !f && y[z])) if (Z === p) { if (ra) { if (!ea || --ea < D) if (l[D++] = t, b && D === b) return T(c, D + (m || 0), l) } else y[z] = p + 1; A = !0 } else d && (z = r[Z] || (r[Z] = []), z[z.length] = t) } if (Y && !A && !d) break } else if (Y && !d) return T(c, h, x) } if (C) if (p = C.length, g) for (k = m ? parseInt(m, 10) : 0; k < p; k++) a = C[k], w["@" + a] || (l[D++] = a); else l = C; if (d) for (D = l.length, X ? (p = parseInt(X[0], 10) + 1, k = parseInt(X[1], 10) + 1) : (p = r.length, k = 0); p--;) if (t = r[p]) { for (G = t.length; k < G; k++) if (d = t[k], !g || !w["@" + d]) if (l[D++] = d, b && D === b) return T(c, p + ":" + k, l); k = 0 } } else !n || e && "not" === e[0] || (l = a[0], m && (m = parseInt(m[0], 10))); b && (g = l.length, m && m > g && (m = 0), m = m || 0, h = m + b, h < g ? l = l.slice(m, h) : (h = 0, m && (l = l.slice(m)))); return T(c, h, l) } function M(a) { return "string" === typeof a } function E(a) { return a.constructor === Array } function O(a) { return "function" === typeof a } function J(a) { return "object" === typeof a } function H(a) { return "undefined" === typeof a } function ia(a) { const b = Array(a); for (let c = 0; c < a; c++) b[c] = B(); return b } function B() { return Object.create(null) } function sa() { let a, b; self.onmessage = function (c) { if (c = c.data) if (c.search) { const d = b.search(c.content, c.threshold ? { limit: c.limit, threshold: c.threshold, where: c.where } : c.limit); self.postMessage({ id: a, content: c.content, limit: c.limit, result: d }) } else c.add ? b.add(c.id, c.content) : c.update ? b.update(c.id, c.content) : c.remove ? b.remove(c.id) : c.clear ? b.clear() : c.info ? (c = b.info(), c.worker = a, console.log(c)) : c.register && (a = c.id, c.options.cache = !1, c.options.async = !1, c.options.worker = !1, b = (new Function(c.register.substring(c.register.indexOf("{") + 1, c.register.lastIndexOf("}"))))(), b = new b(c.options)) } } function ta(a, b, c, d) { a = I("flexsearch", "id" + a, sa, function (f) { (f = f.data) && f.result && d(f.id, f.content, f.result, f.limit, f.where, f.cursor, f.suggest) }, b); const e = ma.toString(); c.id = b; a.postMessage({ register: e, options: c, id: b }); return a } const F = { encode: "icase", f: "forward", split: /\W+/, cache: !1, async: !1, g: !1, D: !1, a: !1, b: 9, threshold: 0, depth: 0 }, ja = { memory: { encode: "extra", f: "strict", threshold: 0, b: 1 }, speed: { encode: "icase", f: "strict", threshold: 1, b: 3, depth: 2 }, match: { encode: "extra", f: "full", threshold: 1, b: 3 }, score: { encode: "extra", f: "strict", threshold: 1, b: 9, depth: 4 }, balance: { encode: "balance", f: "strict", threshold: 0, b: 3, depth: 3 }, fast: { encode: "icase", f: "strict", threshold: 8, b: 9, depth: 1 } }, aa = []; let na = 0; const ka = {}, la = {}; v.create = function (a, b) { return new v(a, b) }; v.registerMatcher = function (a) { for (const b in a) a.hasOwnProperty(b) && aa.push(q(b), a[b]); return this }; v.registerEncoder = function (a, b) { U[a] = b.bind(U); return this }; v.registerLanguage = function (a, b) { ka[a] = b.filter; la[a] = b.stemmer; return this }; v.encode = function (a, b) { return U[a](b) }; v.prototype.init = function (a, b) { this.v = []; if (b) { var c = b.preset; a = b } else a || (a = F), c = a.preset; b = {}; M(a) ? (b = ja[a], a = {}) : c && (b = ja[c]); if (c = a.worker) if ("undefined" === typeof Worker) a.worker = !1, this.m = null; else { var d = parseInt(c, 10) || 4; this.C = -1; this.u = 0; this.o = []; this.F = null; this.m = Array(d); for (var e = 0; e < d; e++) this.m[e] = ta(this.id, e, a, K.bind(this)) } this.f = a.tokenize || b.f || this.f || F.f; this.split = a.split || this.split || F.split; this.D = a.rtl || this.D || F.D; this.async = "undefined" === typeof Promise || H(c = a.async) ? this.async || F.async : c; this.g = H(c = a.worker) ? this.g || F.g : c; this.threshold = H(c = a.threshold) ? b.threshold || this.threshold || F.threshold : c; this.b = H(c = a.resolution) ? c = b.b || this.b || F.b : c; c <= this.threshold && (this.b = this.threshold + 1); this.depth = "strict" !== this.f || H(c = a.depth) ? b.depth || this.depth || F.depth : c; this.w = (c = H(c = a.encode) ? b.encode || F.encode : c) && U[c] && U[c].bind(U) || (O(c) ? c : this.w || !1); (c = a.matcher) && this.addMatcher(c); if (c = (b = a.lang) || a.filter) { M(c) && (c = ka[c]); if (E(c)) { d = this.w; e = B(); for (var f = 0; f < c.length; f++) { var g = d ? d(c[f]) : c[f]; e[g] = 1 } c = e } this.filter = c } if (c = b || a.stemmer) { var h; b = M(c) ? la[c] : c; d = this.w; e = []; for (h in b) b.hasOwnProperty(h) && (f = d ? d(h) : h, e.push(q(f + "($|\\W)"), d ? d(b[h]) : b[h])); this.stemmer = h = e } this.a = e = (c = a.doc) ? S(c) : this.a || F.a; this.j = ia(this.b - (this.threshold || 0)); this.i = B(); this.c = B(); if (e) { this.h = B(); a.doc = null; h = e.index = {}; b = e.keys = []; d = e.field; f = e.tag; E(e.id) || (e.id = e.id.split(":")); if (f) { this.G = B(); g = B(); if (d) if (M(d)) g[d] = a; else if (E(d)) for (let l = 0; l < d.length; l++) g[d[l]] = a; else J(d) && (g = d); E(f) || (e.tag = f = [f]); for (d = 0; d < f.length; d++) this.G[f[d]] = B(); this.I = f; d = g } if (d) { let l; E(d) || (J(d) ? (l = d, e.field = d = Object.keys(d)) : e.field = d = [d]); for (e = 0; e < d.length; e++) f = d[e], E(f) || (l && (a = l[f]), b[e] = f, d[e] = f.split(":")), h[f] = new v(a), h[f].h = this.h } } this.B = !0; this.l = (this.cache = c = H(c = a.cache) ? this.cache || F.cache : c) ? new ua(c) : !1; return this }; v.prototype.encode = function (a) { a && aa.length && (a = Q(a, aa)); a && this.v.length && (a = Q(a, this.v)); a && this.w && (a = this.w(a)); a && this.stemmer && (a = Q(a, this.stemmer)); return a }; v.prototype.addMatcher = function (a) { const b = this.v; for (const c in a) a.hasOwnProperty(c) && b.push(q(c), a[c]); return this }; v.prototype.add = function (a, b, c, d, e) { if (this.a && J(a)) return this.A("add", a, b); if (b && M(b) && (a || 0 === a)) { var f = "@" + a; if (this.c[f] && !d) return this.update(a, b); if (this.g) return ++this.C >= this.m.length && (this.C = 0), this.m[this.C].postMessage({ add: !0, id: a, content: b }), this.c[f] = "" + this.C, c && c(), this; if (!e) { if (this.async && "function" !== typeof importScripts) { let r = this; f = new Promise(function (w) { setTimeout(function () { r.add(a, b, null, d, !0); r = null; w() }) }); if (c) f.then(c); else return f; return this } if (c) return this.add(a, b, null, d, !0), c(), this } b = this.encode(b); if (!b.length) return this; c = this.f; e = O(c) ? c(b) : b.split(this.split); this.filter && (e = W(e, this.filter)); const p = B(); p._ctx = B(); const k = e.length, u = this.threshold, t = this.depth, A = this.b, z = this.j, y = this.D; for (let r = 0; r < k; r++) { var g = e[r]; if (g) { var h = g.length, l = (y ? r + 1 : k - r) / k, m = ""; switch (c) { case "reverse": case "both": for (var n = h; --n;) m = g[n] + m, V(z, p, m, a, y ? 1 : (h - n) / h, l, u, A - 1); m = ""; case "forward": for (n = 0; n < h; n++) m += g[n], V(z, p, m, a, y ? (n + 1) / h : 1, l, u, A - 1); break; case "full": for (n = 0; n < h; n++) { const w = (y ? n + 1 : h - n) / h; for (let x = h; x > n; x--) m = g.substring(n, x), V(z, p, m, a, w, l, u, A - 1) } break; default: if (h = V(z, p, g, a, 1, l, u, A - 1), t && 1 < k && h >= u) for (h = p._ctx[g] || (p._ctx[g] = B()), g = this.i[g] || (this.i[g] = ia(A - (u || 0))), l = r - t, m = r + t + 1, 0 > l && (l = 0), m > k && (m = k); l < m; l++) l !== r && V(g, h, e[l], a, 0, A - (l < r ? r - l : l - r), u, A - 1) } } } this.c[f] = 1; this.B = !1 } return this }; v.prototype.A = function (a, b, c) { if (E(b)) for (let l = 0, m = b.length; l < m; l++) { if (l === m - 1) return this.A(a, b[l], c); this.A(a, b[l]) } else { const l = this.a.index, m = this.a.keys; var d = this.a.tag, e = this.a.id; let n; let p; for (var f = 0; f < e.length; f++) n = (n || b)[e[f]]; if (d) { for (e = 0; e < d.length; e++) { var g = d[e]; var h = g.split(":"); for (f = 0; f < h.length; f++) p = (p || b)[h[f]]; p = "@" + p } h = this.G[g]; h = h[p] || (h[p] = []) } if ("remove" === a) { delete this.h[n]; for (let k = 0, u = m.length; k < u; k++) { if (k === u - 1) return l[m[k]].remove(n, c), this; l[m[k]].remove(n) } } e = this.a.field; h && (h[h.length] = b); this.h[n] = b; for (let k = 0, u = e.length; k < u; k++) { d = e[k]; let t; for (g = 0; g < d.length; g++) t = (t || b)[d[g]]; d = l[m[k]]; g = "add" === a ? d.add : d.update; k === u - 1 ? g.call(d, n, t, c) : g.call(d, n, t) } } return this }; v.prototype.update = function (a, b, c) { if (this.a && J(a)) return this.A("update", a, b); this.c["@" + a] && M(b) && (this.remove(a), this.add(a, b, c, !0)); return this }; v.prototype.remove = function (a, b, c) { if (this.a && J(a)) return this.A("remove", a, b); var d = "@" + a; if (this.c[d]) { if (this.g) return this.m[this.c[d]].postMessage({ remove: !0, id: a }), delete this.c[d], b && b(), this; if (!c) { if (this.async && "function" !== typeof importScripts) { let e = this; d = new Promise(function (f) { setTimeout(function () { e.remove(a, null, !0); e = null; f() }) }); if (b) d.then(b); else return d; return this } if (b) return this.remove(a, null, !0), b(), this } for (b = 0; b < this.b - (this.threshold || 0); b++) ba(this.j[b], a); this.depth && ba(this.i, a); delete this.c[d]; this.B = !1 } return this }; let L; v.prototype.search = function (a, b, c, d) { if (J(b)) { if (E(b)) for (var e = 0; e < b.length; e++) b[e].query = a; else b.query = a; a = b; b = 1E3 } else b && O(b) ? (c = b, b = 1E3) : b || 0 === b || (b = 1E3); let f = [], g = a; let h, l, m; if (J(a) && !E(a)) { c || (c = a.callback) && (g.callback = null); l = a.sort; h = a.page; b = a.limit; var n = a.threshold; m = a.suggest; a = a.query } if (this.a) { n = this.a.index; const y = g.where; var p = g.bool || "or", k = g.field; let r = p; let w, x; if (k) E(k) || (k = [k]); else if (E(g)) { var u = g; k = []; r = []; for (var t = 0; t < g.length; t++) d = g[t], e = d.bool || p, k[t] = d.field, r[t] = e, "not" === e ? w = !0 : "and" === e && (x = !0) } else k = this.a.keys; p = k.length; for (t = 0; t < p; t++) u && (g = u[t]), h && !M(g) && (g.page = null, g.limit = 0), f[t] = n[k[t]].search(g, 0); if (this.g) { this.F = c; this.u = 0; this.o = []; for (n = 0; n < this.g; n++) this.m[n].postMessage({ search: !0, limit: b, content: g }); return } if (c) return c(P.call(this, a, r, f, l, b, m, y, h, x, w)); if (this.async) { const G = this; return new Promise(function (C) { Promise.all(f).then(function (D) { C(P.call(G, a, r, D, l, b, m, y, h, x, w)) }) }) } return P.call(this, a, r, f, l, b, m, y, h, x, w) } n || (n = this.threshold || 0); if (!d) { if (this.async && "function" !== typeof importScripts) { let y = this; n = new Promise(function (r) { setTimeout(function () { r(y.search(g, b, null, !0)); y = null }) }); if (c) n.then(c); else return n; return this } if (c) return c(this.search(g, b, null, !0)), this } if (!a || !M(a)) return f; g = a; if (this.cache) if (this.B) { if (c = this.l.get(a)) return c } else this.l.clear(), this.B = !0; g = this.encode(g); if (!g.length) return f; c = this.f; c = O(c) ? c(g) : g.split(this.split); this.filter && (c = W(c, this.filter)); u = c.length; d = !0; e = []; const A = B(); let z = 0; 1 < u && (this.depth && "strict" === this.f ? p = !0 : c.sort(qa)); if (!p || (t = this.i)) { const y = this.b; for (; z < u; z++) { let r = c[z]; if (r) { if (p) { if (!k) if (t[r]) k = r, A[r] = 1; else if (!m) return f; if (m && z === u - 1 && !e.length) p = !1, r = k || r, A[r] = 0; else if (!k) continue } if (!A[r]) { const w = []; let x = !1, G = 0; const C = p ? t[k] : this.j; if (C) { let D; for (let N = 0; N < y - n; N++) if (D = C[N] && C[N][r]) w[G++] = D, x = !0 } if (x) k = r, e[e.length] = 1 < G ? w.concat.apply([], w) : w[0]; else if (!m) { d = !1; break } A[r] = 1 } } } } else d = !1; d && (f = ha(e, b, h, m)); this.cache && this.l.set(a, f); return f }; v.prototype.find = function (a, b) { return this.where(a, b, 1)[0] || null }; v.prototype.where = function (a, b, c, d) { const e = this.h, f = []; let g = 0; let h; var l; let m; if (J(a)) { c || (c = b); var n = Object.keys(a); var p = n.length; h = !1; if (1 === p && "id" === n[0]) return [e[a.id]]; if ((l = this.I) && !d) for (var k = 0; k < l.length; k++) { var u = l[k], t = a[u]; if (!H(t)) { m = this.G[u]["@" + t]; if (0 === --p) return m; n.splice(n.indexOf(u), 1); delete a[u]; break } } l = Array(p); for (k = 0; k < p; k++) l[k] = n[k].split(":") } else { if (O(a)) { b = d || Object.keys(e); c = b.length; for (n = 0; n < c; n++) p = e[b[n]], a(p) && (f[g++] = p); return f } if (H(b)) return [e[a]]; if ("id" === a) return [e[b]]; n = [a]; p = 1; l = [a.split(":")]; h = !0 } d = m || d || Object.keys(e); k = d.length; for (u = 0; u < k; u++) { t = m ? d[u] : e[d[u]]; let A = !0; for (let z = 0; z < p; z++) { h || (b = a[n[z]]); const y = l[z], r = y.length; let w = t; if (1 < r) for (let x = 0; x < r; x++) w = w[y[x]]; else w = w[y[0]]; if (w !== b) { A = !1; break } } if (A && (f[g++] = t, c && g === c)) break } return f }; v.prototype.info = function () { if (this.g) for (let a = 0; a < this.g; a++) this.m[a].postMessage({ info: !0, id: this.id }); else return { id: this.id, items: this.length, cache: this.cache && this.cache.s ? this.cache.s.length : !1, matcher: aa.length + (this.v ? this.v.length : 0), worker: this.g, threshold: this.threshold, depth: this.depth, resolution: this.b, contextual: this.depth && "strict" === this.f } }; v.prototype.clear = function () { return this.destroy().init() }; v.prototype.destroy = function () { this.cache && (this.l.clear(), this.l = null); this.j = this.i = this.c = null; if (this.a) { const a = this.a.keys; for (let b = 0; b < a.length; b++) this.a.index[a[b]].destroy(); this.a = this.h = null } return this }; v.prototype.export = function () { let a; if (this.a) { const b = this.a.keys; a = Array(b.length + 1); let c = 0; for (; c < b.length; c++) { const d = this.a.index[b[c]]; a[c] = [d.j, d.i, Object.keys(d.c)] } a[c] = this.h } else a = [this.j, this.i, Object.keys(this.c)]; return JSON.stringify(a) }; v.prototype.import = function (a) { a = JSON.parse(a); const b = B(); if (this.a) { var c = this.a.keys, d = c.length, e = a[0][2]; for (var f = 0; f < e.length; f++) b[e[f]] = 1; for (e = 0; e < d; e++) f = this.a.index[c[e]], f.j = a[e][0], f.i = a[e][1], f.c = b, f.h = a[d]; this.h = a[d] } else { c = a[2]; for (d = 0; d < c.length; d++) b[c[d]] = 1; this.j = a[0]; this.i = a[1]; this.c = b } }; const U = { icase: function (a) { return a.toLowerCase() }, simple: function () { const a = [q("[\u00e0\u00e1\u00e2\u00e3\u00e4\u00e5]"), "a", q("[\u00e8\u00e9\u00ea\u00eb]"), "e", q("[\u00ec\u00ed\u00ee\u00ef]"), "i", q("[\u00f2\u00f3\u00f4\u00f5\u00f6\u0151]"), "o", q("[\u00f9\u00fa\u00fb\u00fc\u0171]"), "u", q("[\u00fd\u0177\u00ff]"), "y", q("\u00f1"), "n", q("[\u00e7c]"), "k", q("\u00df"), "s", q(" & "), " and ", q("[-/]"), " ", q("[^a-z0-9 ]"), "", q("\\s+"), " "]; return function (b) { b = Q(b.toLowerCase(), a); return " " === b ? "" : b } }(), advanced: function () { const a = [q("ae"), "a", q("ai"), "ei", q("ay"), "ei", q("ey"), "ei", q("oe"), "o", q("ue"), "u", q("ie"), "i", q("sz"), "s", q("zs"), "s", q("sh"), "s", q("ck"), "k", q("cc"), "k", q("th"), "t", q("dt"), "t", q("ph"), "f", q("pf"), "f", q("ou"), "o", q("uo"), "u"]; return function (b, c) { if (!b) return b; b = this.simple(b); 2 < b.length && (b = Q(b, a)); c || 1 < b.length && (b = ca(b)); return b } }(), extra: function () { const a = [q("p"), "b", q("z"), "s", q("[cgq]"), "k", q("n"), "m", q("d"), "t", q("[vw]"), "f", q("[aeiouy]"), ""]; return function (b) { if (!b) return b; b = this.advanced(b, !0); if (1 < b.length) { b = b.split(" "); for (let c = 0; c < b.length; c++) { const d = b[c]; 1 < d.length && (b[c] = d[0] + Q(d.substring(1), a)) } b = b.join(" "); b = ca(b) } return b } }(), balance: function () { const a = [q("[-/]"), " ", q("[^a-z0-9 ]"), "", q("\\s+"), " "]; return function (b) { return ca(Q(b.toLowerCase(), a)) } }() }, ua = function () { function a(b) { this.clear(); this.H = !0 !== b && b } a.prototype.clear = function () { this.cache = B(); this.count = B(); this.index = B(); this.s = [] }; a.prototype.set = function (b, c) { if (this.H && H(this.cache[b])) { let d = this.s.length; if (d === this.H) { d--; const e = this.s[d]; delete this.cache[e]; delete this.count[e]; delete this.index[e] } this.index[b] = d; this.s[d] = b; this.count[b] = -1; this.cache[b] = c; this.get(b) } else this.cache[b] = c }; a.prototype.get = function (b) { const c = this.cache[b]; if (this.H && c) { var d = ++this.count[b]; const f = this.index; let g = f[b]; if (0 < g) { const h = this.s; for (var e = g; this.count[h[--g]] <= d && -1 !== g;); g++; if (g !== e) { for (d = e; d > g; d--) e = h[d - 1], h[d] = e, f[e] = d; h[g] = b; f[b] = g } } } return c }; return a }(); return v }(function () { const I = {}, R = "undefined" !== typeof Blob && "undefined" !== typeof URL && URL.createObjectURL; return function (v, K, S, W, P) { S = R ? URL.createObjectURL(new Blob(["(" + S.toString() + ")()"], { type: "text/javascript" })) : v + ".min.js"; v += "-" + K; I[v] || (I[v] = []); I[v][P] = new Worker(S); I[v][P].onmessage = W; return I[v][P] } }()), this);
	</script>

</body>

</html>